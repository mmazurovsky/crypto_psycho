// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'chart_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ChartModel _$ChartModelFromJson(Map<String, dynamic> json) {
  return _ChartModel.fromJson(json);
}

/// @nodoc
mixin _$ChartModel {
  ChartPriceModel get bitcoin => throw _privateConstructorUsedError;
  ChartPriceModel get solana => throw _privateConstructorUsedError;
  ChartPriceModel get polkadot => throw _privateConstructorUsedError;
  ChartPriceModel get cardano => throw _privateConstructorUsedError;
  ChartPriceModel get ethereum => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChartModelCopyWith<ChartModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChartModelCopyWith<$Res> {
  factory $ChartModelCopyWith(
          ChartModel value, $Res Function(ChartModel) then) =
      _$ChartModelCopyWithImpl<$Res>;
  $Res call(
      {ChartPriceModel bitcoin,
      ChartPriceModel solana,
      ChartPriceModel polkadot,
      ChartPriceModel cardano,
      ChartPriceModel ethereum});

  $ChartPriceModelCopyWith<$Res> get bitcoin;
  $ChartPriceModelCopyWith<$Res> get solana;
  $ChartPriceModelCopyWith<$Res> get polkadot;
  $ChartPriceModelCopyWith<$Res> get cardano;
  $ChartPriceModelCopyWith<$Res> get ethereum;
}

/// @nodoc
class _$ChartModelCopyWithImpl<$Res> implements $ChartModelCopyWith<$Res> {
  _$ChartModelCopyWithImpl(this._value, this._then);

  final ChartModel _value;
  // ignore: unused_field
  final $Res Function(ChartModel) _then;

  @override
  $Res call({
    Object? bitcoin = freezed,
    Object? solana = freezed,
    Object? polkadot = freezed,
    Object? cardano = freezed,
    Object? ethereum = freezed,
  }) {
    return _then(_value.copyWith(
      bitcoin: bitcoin == freezed
          ? _value.bitcoin
          : bitcoin // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      solana: solana == freezed
          ? _value.solana
          : solana // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      polkadot: polkadot == freezed
          ? _value.polkadot
          : polkadot // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      cardano: cardano == freezed
          ? _value.cardano
          : cardano // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      ethereum: ethereum == freezed
          ? _value.ethereum
          : ethereum // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
    ));
  }

  @override
  $ChartPriceModelCopyWith<$Res> get bitcoin {
    return $ChartPriceModelCopyWith<$Res>(_value.bitcoin, (value) {
      return _then(_value.copyWith(bitcoin: value));
    });
  }

  @override
  $ChartPriceModelCopyWith<$Res> get solana {
    return $ChartPriceModelCopyWith<$Res>(_value.solana, (value) {
      return _then(_value.copyWith(solana: value));
    });
  }

  @override
  $ChartPriceModelCopyWith<$Res> get polkadot {
    return $ChartPriceModelCopyWith<$Res>(_value.polkadot, (value) {
      return _then(_value.copyWith(polkadot: value));
    });
  }

  @override
  $ChartPriceModelCopyWith<$Res> get cardano {
    return $ChartPriceModelCopyWith<$Res>(_value.cardano, (value) {
      return _then(_value.copyWith(cardano: value));
    });
  }

  @override
  $ChartPriceModelCopyWith<$Res> get ethereum {
    return $ChartPriceModelCopyWith<$Res>(_value.ethereum, (value) {
      return _then(_value.copyWith(ethereum: value));
    });
  }
}

/// @nodoc
abstract class _$$_ChartModelCopyWith<$Res>
    implements $ChartModelCopyWith<$Res> {
  factory _$$_ChartModelCopyWith(
          _$_ChartModel value, $Res Function(_$_ChartModel) then) =
      __$$_ChartModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {ChartPriceModel bitcoin,
      ChartPriceModel solana,
      ChartPriceModel polkadot,
      ChartPriceModel cardano,
      ChartPriceModel ethereum});

  @override
  $ChartPriceModelCopyWith<$Res> get bitcoin;
  @override
  $ChartPriceModelCopyWith<$Res> get solana;
  @override
  $ChartPriceModelCopyWith<$Res> get polkadot;
  @override
  $ChartPriceModelCopyWith<$Res> get cardano;
  @override
  $ChartPriceModelCopyWith<$Res> get ethereum;
}

/// @nodoc
class __$$_ChartModelCopyWithImpl<$Res> extends _$ChartModelCopyWithImpl<$Res>
    implements _$$_ChartModelCopyWith<$Res> {
  __$$_ChartModelCopyWithImpl(
      _$_ChartModel _value, $Res Function(_$_ChartModel) _then)
      : super(_value, (v) => _then(v as _$_ChartModel));

  @override
  _$_ChartModel get _value => super._value as _$_ChartModel;

  @override
  $Res call({
    Object? bitcoin = freezed,
    Object? solana = freezed,
    Object? polkadot = freezed,
    Object? cardano = freezed,
    Object? ethereum = freezed,
  }) {
    return _then(_$_ChartModel(
      bitcoin: bitcoin == freezed
          ? _value.bitcoin
          : bitcoin // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      solana: solana == freezed
          ? _value.solana
          : solana // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      polkadot: polkadot == freezed
          ? _value.polkadot
          : polkadot // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      cardano: cardano == freezed
          ? _value.cardano
          : cardano // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
      ethereum: ethereum == freezed
          ? _value.ethereum
          : ethereum // ignore: cast_nullable_to_non_nullable
              as ChartPriceModel,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ChartModel extends _ChartModel {
  const _$_ChartModel(
      {required this.bitcoin,
      required this.solana,
      required this.polkadot,
      required this.cardano,
      required this.ethereum})
      : super._();

  factory _$_ChartModel.fromJson(Map<String, dynamic> json) =>
      _$$_ChartModelFromJson(json);

  @override
  final ChartPriceModel bitcoin;
  @override
  final ChartPriceModel solana;
  @override
  final ChartPriceModel polkadot;
  @override
  final ChartPriceModel cardano;
  @override
  final ChartPriceModel ethereum;

  @override
  String toString() {
    return 'ChartModel(bitcoin: $bitcoin, solana: $solana, polkadot: $polkadot, cardano: $cardano, ethereum: $ethereum)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChartModel &&
            const DeepCollectionEquality().equals(other.bitcoin, bitcoin) &&
            const DeepCollectionEquality().equals(other.solana, solana) &&
            const DeepCollectionEquality().equals(other.polkadot, polkadot) &&
            const DeepCollectionEquality().equals(other.cardano, cardano) &&
            const DeepCollectionEquality().equals(other.ethereum, ethereum));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(bitcoin),
      const DeepCollectionEquality().hash(solana),
      const DeepCollectionEquality().hash(polkadot),
      const DeepCollectionEquality().hash(cardano),
      const DeepCollectionEquality().hash(ethereum));

  @JsonKey(ignore: true)
  @override
  _$$_ChartModelCopyWith<_$_ChartModel> get copyWith =>
      __$$_ChartModelCopyWithImpl<_$_ChartModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChartModelToJson(
      this,
    );
  }
}

abstract class _ChartModel extends ChartModel {
  const factory _ChartModel(
      {required final ChartPriceModel bitcoin,
      required final ChartPriceModel solana,
      required final ChartPriceModel polkadot,
      required final ChartPriceModel cardano,
      required final ChartPriceModel ethereum}) = _$_ChartModel;
  const _ChartModel._() : super._();

  factory _ChartModel.fromJson(Map<String, dynamic> json) =
      _$_ChartModel.fromJson;

  @override
  ChartPriceModel get bitcoin;
  @override
  ChartPriceModel get solana;
  @override
  ChartPriceModel get polkadot;
  @override
  ChartPriceModel get cardano;
  @override
  ChartPriceModel get ethereum;
  @override
  @JsonKey(ignore: true)
  _$$_ChartModelCopyWith<_$_ChartModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ChartPriceModel _$ChartPriceModelFromJson(Map<String, dynamic> json) {
  return _ChartPriceModel.fromJson(json);
}

/// @nodoc
mixin _$ChartPriceModel {
  double get usd => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChartPriceModelCopyWith<ChartPriceModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChartPriceModelCopyWith<$Res> {
  factory $ChartPriceModelCopyWith(
          ChartPriceModel value, $Res Function(ChartPriceModel) then) =
      _$ChartPriceModelCopyWithImpl<$Res>;
  $Res call({double usd});
}

/// @nodoc
class _$ChartPriceModelCopyWithImpl<$Res>
    implements $ChartPriceModelCopyWith<$Res> {
  _$ChartPriceModelCopyWithImpl(this._value, this._then);

  final ChartPriceModel _value;
  // ignore: unused_field
  final $Res Function(ChartPriceModel) _then;

  @override
  $Res call({
    Object? usd = freezed,
  }) {
    return _then(_value.copyWith(
      usd: usd == freezed
          ? _value.usd
          : usd // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_ChartPriceModelCopyWith<$Res>
    implements $ChartPriceModelCopyWith<$Res> {
  factory _$$_ChartPriceModelCopyWith(
          _$_ChartPriceModel value, $Res Function(_$_ChartPriceModel) then) =
      __$$_ChartPriceModelCopyWithImpl<$Res>;
  @override
  $Res call({double usd});
}

/// @nodoc
class __$$_ChartPriceModelCopyWithImpl<$Res>
    extends _$ChartPriceModelCopyWithImpl<$Res>
    implements _$$_ChartPriceModelCopyWith<$Res> {
  __$$_ChartPriceModelCopyWithImpl(
      _$_ChartPriceModel _value, $Res Function(_$_ChartPriceModel) _then)
      : super(_value, (v) => _then(v as _$_ChartPriceModel));

  @override
  _$_ChartPriceModel get _value => super._value as _$_ChartPriceModel;

  @override
  $Res call({
    Object? usd = freezed,
  }) {
    return _then(_$_ChartPriceModel(
      usd: usd == freezed
          ? _value.usd
          : usd // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ChartPriceModel extends _ChartPriceModel {
  const _$_ChartPriceModel({required this.usd}) : super._();

  factory _$_ChartPriceModel.fromJson(Map<String, dynamic> json) =>
      _$$_ChartPriceModelFromJson(json);

  @override
  final double usd;

  @override
  String toString() {
    return 'ChartPriceModel(usd: $usd)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChartPriceModel &&
            const DeepCollectionEquality().equals(other.usd, usd));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(usd));

  @JsonKey(ignore: true)
  @override
  _$$_ChartPriceModelCopyWith<_$_ChartPriceModel> get copyWith =>
      __$$_ChartPriceModelCopyWithImpl<_$_ChartPriceModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChartPriceModelToJson(
      this,
    );
  }
}

abstract class _ChartPriceModel extends ChartPriceModel {
  const factory _ChartPriceModel({required final double usd}) =
      _$_ChartPriceModel;
  const _ChartPriceModel._() : super._();

  factory _ChartPriceModel.fromJson(Map<String, dynamic> json) =
      _$_ChartPriceModel.fromJson;

  @override
  double get usd;
  @override
  @JsonKey(ignore: true)
  _$$_ChartPriceModelCopyWith<_$_ChartPriceModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ChartEntity _$ChartEntityFromJson(Map<String, dynamic> json) {
  return _ChartEntity.fromJson(json);
}

/// @nodoc
mixin _$ChartEntity {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get priceInUsd => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChartEntityCopyWith<ChartEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChartEntityCopyWith<$Res> {
  factory $ChartEntityCopyWith(
          ChartEntity value, $Res Function(ChartEntity) then) =
      _$ChartEntityCopyWithImpl<$Res>;
  $Res call({String id, String name, double priceInUsd});
}

/// @nodoc
class _$ChartEntityCopyWithImpl<$Res> implements $ChartEntityCopyWith<$Res> {
  _$ChartEntityCopyWithImpl(this._value, this._then);

  final ChartEntity _value;
  // ignore: unused_field
  final $Res Function(ChartEntity) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? priceInUsd = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      priceInUsd: priceInUsd == freezed
          ? _value.priceInUsd
          : priceInUsd // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$$_ChartEntityCopyWith<$Res>
    implements $ChartEntityCopyWith<$Res> {
  factory _$$_ChartEntityCopyWith(
          _$_ChartEntity value, $Res Function(_$_ChartEntity) then) =
      __$$_ChartEntityCopyWithImpl<$Res>;
  @override
  $Res call({String id, String name, double priceInUsd});
}

/// @nodoc
class __$$_ChartEntityCopyWithImpl<$Res> extends _$ChartEntityCopyWithImpl<$Res>
    implements _$$_ChartEntityCopyWith<$Res> {
  __$$_ChartEntityCopyWithImpl(
      _$_ChartEntity _value, $Res Function(_$_ChartEntity) _then)
      : super(_value, (v) => _then(v as _$_ChartEntity));

  @override
  _$_ChartEntity get _value => super._value as _$_ChartEntity;

  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? priceInUsd = freezed,
  }) {
    return _then(_$_ChartEntity(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      priceInUsd: priceInUsd == freezed
          ? _value.priceInUsd
          : priceInUsd // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ChartEntity extends _ChartEntity {
  const _$_ChartEntity(
      {required this.id, required this.name, required this.priceInUsd})
      : super._();

  factory _$_ChartEntity.fromJson(Map<String, dynamic> json) =>
      _$$_ChartEntityFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final double priceInUsd;

  @override
  String toString() {
    return 'ChartEntity(id: $id, name: $name, priceInUsd: $priceInUsd)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChartEntity &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.priceInUsd, priceInUsd));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(priceInUsd));

  @JsonKey(ignore: true)
  @override
  _$$_ChartEntityCopyWith<_$_ChartEntity> get copyWith =>
      __$$_ChartEntityCopyWithImpl<_$_ChartEntity>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChartEntityToJson(
      this,
    );
  }
}

abstract class _ChartEntity extends ChartEntity {
  const factory _ChartEntity(
      {required final String id,
      required final String name,
      required final double priceInUsd}) = _$_ChartEntity;
  const _ChartEntity._() : super._();

  factory _ChartEntity.fromJson(Map<String, dynamic> json) =
      _$_ChartEntity.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  double get priceInUsd;
  @override
  @JsonKey(ignore: true)
  _$$_ChartEntityCopyWith<_$_ChartEntity> get copyWith =>
      throw _privateConstructorUsedError;
}
